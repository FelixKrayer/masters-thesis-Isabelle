% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}
\label{chapter:introduction}
  Isabelle/HOL provides a fleshed out system for defining datatypes and codatatypes built on the theory of \acp{BNF} developed by Traytel et al.~\cite{traytel2012foundational}. The \textbf{datatype} command developed by Blanchette et al.~\cite{blanchette2014truly} based on this theory allows Isabelle users to construct possibly recursive datatypes from primitive, built-in datatypes like the list, product or function type. The resulting datatype is equipped with several predicates that allow for reasoning about the datatype, for example through case distinction and structural induction.

  However, these regular datatypes are not well suited to express and reason about lambda calculus terms. As an example we consider lambda terms with parallel let bindings, where a term is either a variable, a lambda abstraction, an application or a parallel let binding. Concretely, we want to represent the following syntax, where $\mathtt{x}$ are variable names.
  \[
    \mathtt{t} := \mathtt{x}\; |\; (\lambda x.\; t)\; |\; \mathtt{t}_1\; \mathtt{t}_2\; |\; \texttt{let } \mathtt{x}_1 = \mathtt{t}_1 \texttt{ and } \dots \texttt{ and } \mathtt{x}_n = \mathtt{t}_n \texttt{ in } \mathtt{t}_{n+1}
  \]
  We can express the structure of these terms with a regular Isabelle datatype as follows, where $\alpha$ is the type of variable names:
  \begin{align*}
    &\textbf{datatype}\; \alpha\; \textsf{ltrm} = \text{Var}\; \alpha\; | \;\text{Abs}\; \alpha\; \text{"}\alpha\; \textsf{ltrm}\text{"}\; | \;\text{App}\; \text{"}\alpha\; \textsf{ltrm}\text{"}\; \text{"}\alpha\; \textsf{ltrm}\text{"}\\
    &\indent | \;\text{Let}\; \text{"}(\alpha \times \alpha\; \textsf{ltrm})\; \textsf{list}\text{"}\; \text{"}\alpha\; \textsf{ltrm}\text{"}
  \end{align*}
  However, this representation is not ideal. For example, it does not consider $\alpha$-equivalence of lambda terms, i.e., the notion that $(\lambda x.\; x\; z)$ and $(\lambda y.\; y\; z)$ are semantically equivalent terms. This would be desirable, since it facilitates reasoning about the semantics of terms. We could try to quotient the type by $\alpha$-equivalence, but this is a manual process and requires effort.

  Secondly, it would be convenient to have functions for renaming and obtaining free variables in a term. While the map and set function that are provided by the datatype seem like suitable candidates, they do not fulfill these tasks. For example the mapper does not support capture-avoiding substitution, i.e., it might rename a bound variable to the name of a free one, which changes the term semantically.
 
  Furthermore, this datatype represents invalid terms. This makes working with the type tedious, since it calls for a separate definition of and checks for validity. For example, \type{$\alpha$ ltrm} contains "$\text{Let}\; [(\text{Var}\; x, \text{Var}\; y), (\text{Var}\; x, \text{Var}\; z)]\; (\text{Var}\; x)$" as a valid term. This would be the representation of "$\texttt{let } \mathtt{x} = \mathtt{y} \texttt{ and } \mathtt{x} = \mathtt{z} \texttt{ in } \mathtt{x}$" which is not a valid type, since a variable cannot be bound to different terms in the same parallel let binding. This can in theory be solved by defining a subtype of \type{$(\alpha \times \beta)$ list} that only contains lists of pairs, where the first elements of each pair are unique in the list. However, this subtype is not a \ac{BNF} right after that and thus it cannot be used in the recursive definition.

  An important step towards solving these issues has been taken by van Br\"{u}gge et al.~\cite{vanbrugge2025animating} in their implementation of a definitional package for binding-aware datatypes in Isabelle/HOL. They provide a new \textbf{binder\_datatype} command that allows for the definition of datatypes that do not distinguish between $\alpha$-equivalent terms and provide functions for renaming and obtaining the free variables of a term. Furthermore these binding-aware datatypes (or short \textit{binder datatypes}) provide propositions similar to those provided by a regular datatype, e.g., a principle for structural induction. This package is built on the theory of \acp{MRBNF}, a generalization of \acp{BNF} developed by Blanchette et al.~\cite{blanchette2019bindings}.

  Declaring \type{ltrm} as a binder datatype fixes the first two issues regarding $\alpha$-equivalence and the obtaining and renaming of free variables in a capture-avoiding fashion. Additionally, the explicit notion of \textit{bound} variables in \acp{MRBNF} allows us to define a linearized version of \type{$(\alpha \times \beta)$ list} that ensures the pairwise distinctness of $\alpha$ atoms in each element of the type. This is possible, since declaring a variable as bound allows us to restrict the map function to bijections on a certain type variable --- $\alpha$ in this case.

  In general, we call a type \textit{linear} or \textit{non-repetitive} on a type variable $\alpha$, when all its elements only contain pairwise distinct $\alpha$ atoms. As described by Blanchette et al.~\mbox{\cite[ยง4]{blanchette2019bindings}}, complex linear \acp{MRBNF} cannot be built recursively from simpler ones. This is because non-repetitiveness is not closed under fixpoints. Alternatively, we can construct the desired type without taking non-repetitiveness into account, and as a last step take the subset of non-repetitive elements. This produces a type constructor that has the desired properties, however it is not registered as a \ac{MRBNF}. To use the type in the construction of other binder datatypes, it is necessary to prove certain \ac{MRBNF} axioms for it. Conducting these proofs has been a manual process that had to be undertaken for each linear type separately. 
  
  We aim to automate this process of linearization. For this we implement a new command in Isabelle/HOL: \textbf{linearize\_mrbnf}. This command produces a linearized type constructor equipped with the typical \ac{MRBNF} constants and propositions that is non-repetitive on the specified type variables. All proofs are internally conducted in an automated fashion after the user shows two axioms necessary for these proofs --- namely the existence of a non-repetitive element of the type and strong pullback preservation.

  Our new command together with the \textbf{binder\_datatype} command from van Br\"{u}gge et al.~\cite{vanbrugge2025animating} allows us to easily construct a binding aware datatype that represents the lambda terms with parallel let bindings with all the desired properties. This is accomplished through the following two commands:
  \begin{align*}
    &\textbf{linearize\_mrbnf}\; (\text{keys:}\; \alpha :: \text{var},\; \text{vals:}\; \beta)\; \textsf{alist} = \text{"}(\alpha :: \text{var} \times \beta)\; \textsf{list}\text{"}\; \textbf{on}\; \alpha\\
    &\indent \text{by (auto simp: list\_eq\_iff\_nth\_eq map\_prod\_def split\_beta prod\_eq\_iff)}\\%
    \\
    &\textbf{binder\_datatype}\; \alpha\; \textsf{ltrm} = \text{Var}\; \alpha\; | \;\text{Abs}\; \alpha\; \text{"}\alpha\; \textsf{ltrm}\text{"}\; | \;\text{App}\; \text{"}\alpha\; \textsf{ltrm}\text{"}\; \text{"}\alpha\; \textsf{ltrm}\text{"}\\
    &\indent | \;\text{Let}\; \text{"}(\mathtt{fs}::\alpha \times \mathtt{t}::\alpha\; \textsf{ltrm})\; \textsf{list}\text{"}\; \text{"}\mathtt{u}::\alpha\; \textsf{ltrm}\text{"}\; \textbf{binds}\; \mathtt{fs}\; \textbf{in}\; \mathtt{t}\; \mathtt{u}
  \end{align*}

  \paragraph{Structure}\mbox{}\\
  The thesis is structured as follows: First, We introduce \acp{BNF} \dots
