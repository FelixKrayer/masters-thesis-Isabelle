% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Background}
\label{chapter:background}
% cite Isabelle datatype pdf

  This Chapter serves to introduce \acp{BNF} and their generalization to \acp{MRBNF}. 
  \section{Bounded Natural Functors (BNFs)}
    As described in \autoref{chapter:introduction}, \acp{BNF} are essential for constructing datatypes and codatatypes in Isabelle/HOL. Especially for defining a datatype with recursion it is required that the type constructor \type{$'a$ list} is registered as a \ac{BNF}, i.e., it fulfills the \ac{BNF}-axioms. For example the following \textbf{datatype} command only succeeds if \type{$'a$ list}, is a \ac{BNF}.
    \begin{equation*}
      \textbf{datatype}\; 'a\; \textsf{ex} = \text{A}\; \text{"}('a\; \times\; 'a\; \textsf{ex})\; \textsf{list}\text{"}
    \end{equation*}
    Since \acp{BNF} are closed under composition and fixpoints, the resulting datatype (here \type{$'a$ ex}) can be automatically registered as a \ac{BNF} as well.

    The type variables of a \ac{BNF} are divided into two groups: \textit{live} and \textit{dead} variables or \textit{lives} and \textit{deads}. Live variables can be used for recursive datatype definitions, while dead ones do not allow for this. We take the function type $'a\; \Rightarrow\; 'b$ as an example. It's first type argument $'a$ is dead, while the second one $'b$ is live. Thus, of the following the first command succeeds while the second one fails
    \begin{align*}
      &\textbf{datatype}\; 'a\; \textsf{success} = \text{S1}\; |\; \text{S2}\; \text{"}'a\; \Rightarrow\; 'a\; \textsf{success}\text{"}\\
      &\textbf{datatype}\; 'a\; \textsf{fail} = \text{F1}\; |\; \text{F2}\; \text{"}'a\; \textsf{fail}\; \Rightarrow\; 'a\text{"}
    \end{align*}

    \subsection{BNF constants}
      \label{subsec:bnf_constants}
      A \ac{BNF} $F$ with $l$ live variables is characterized by one map and $l$ set functions, a bound and a relator.

      \subsubsection{Map function and functors}
        The $l+1$-ary map function or \textit{mapper} takes one function for each live of $F$ as arguments as well as one $F$ element. The domain types of these functions are the lives of $F$. These functions are recursively applied to the components of an element. The result is a new element of type $F$, where the original type variables are replaced by the range types of the mapped functions. Taking the \type{$'a$ list} type as an example, a \ac{BNF} with one live $'a$, the mapper has the type $\textsf{map}_\textsf{list}\; ::\; ('a\; \Rightarrow\; 'a_1)\; \Rightarrow\; 'a\; \textsf{list}\; \Rightarrow\; 'a_1\; \textsf{list}$.
        
        To make $F$ with its mapper a \textit{functor} on the universe of all types, the mapper has to fulfill two axioms~\cite{traytel2012foundational}. First, mapping the $id$ function on all lives over an element should leave it unchanged. This axiom is named \textsc{map\_id}. Secondly, mapping two lists of functions over an element, e.g., first $f_1 \dots f_l$ and then $g_1 \dots g_l$, should produce the same result as mapping the index-wise composition $(g_1 \circ f_1) \dots (g_l \circ f_l)$ over it once. We name this axiom \textsc{map\_comp} and fully formalize it and all the other axioms in~\autoref{fig:bnf_axioms}.

      \subsubsection{Set functions and naturality}
        A set function or \textit{setter} is defined for each of the $l$ live variables. Applied to an $F$-element, the $i$-th setter returns the set of all components that are part of the element and correspond to the $i$-th live. For example, the setter of the \type{list} type returns the set of elements in the list. We note here that when we write $i$ as an index, we assume it to be in the range $1 \leq i \leq l$.

        The set functions together with the mapper give rise to another property. We want the setters $\textsf{set}_{F,i}$ to be natural transformations from $F$ and $\textsf{map}_F$ to the set and image function. Thus, they should fulfill the \textsc{set\_map} axiom. It states that taking the $i$-th set of an $F$ after mapping $f_1 \dots f_l$ to it, results in the same set as if $i$-th set was taken from the original $F$ before the image of $f_i$ was applied to it. Again, the formalization of \textsc{set\_map} can be found in~\autoref{fig:bnf_axioms}, while~\autoref{fig:set_nat} shows a visualization of it.

        \begin{figure}[!h]
          \centering
          \input{figures/natural_set.tex}
          \caption{$\textsf{set}_{F,i}$ as a natural transformation}
          \label{fig:set_nat}
        \end{figure}

      \subsubsection{Bound and boundedness}
        Lastly, the \ac{BNF} needs a bound. This is an infinite cardinal that may depend on the cardinalities of the dead variables, but not on the of the live variables. The bound is used for the \textsc{set\_bd} axiom (formalized in \autoref{fig:bnf_axioms}) to ensure that the component sets obtained by the setters are bounded. This ensures that the branching of a recursively defined datatype is bounded.

      \subsubsection{Relator and shapes}
        The relator is used to build a relation on $F$ by relating the components of an $F$ element. It takes one relation for each live, that relates the corresponding type variables of the two $F$s that are to be related. As an example we give the type and definition of the relator for the product type as follows:
        \begin{align*}
          \textsf{rel}_\textsf{prod} ::\; &('a_1\; \Rightarrow\; 'a_2\; \Rightarrow\; \textsf{bool})\; \Rightarrow\; ('b_1\; \Rightarrow\; 'b_2\; \Rightarrow\; \textsf{bool})\Rightarrow\\
            &('a_1\; \times\; 'b_1)\; \Rightarrow\; ('a_2\; \times\; 'b_2)\; \Rightarrow\; \textsf{bool}\\
          \textsf{rel}_\textsf{prod}\; R\; S\; p_1\; p_2 :=\; & R\; (fst\; p_1)\; (fst\; p_2)\land S\; (snd\; p_1)\; (snd\; p_2)
        \end{align*}

        \noindent Considering the list type again, we make an interesting observation: There are some \type{$'a$ list}s $xs$ and $ys$ that the relator cannot relate, no matter which $'a$ relation is chosen. The relator on lists is index-wise defined, i.e., the $'a$ relation must relate the elements of both lists for each index. Consequently lists of different length cannot be positively related. We think of the length of a list as its \textit{shape}. We can generalize this idea of shape to an arbitrary type constructor $F$. The shape of an $F$ element is defined by the way it is constructed and the relator can only ever relate those that have the same or equivalent shape, i.e., it will always evaluate to $false$, when two elements of different shape are given, regardless of the relations given to the relator. We can think of an element of type $F$ as a container that has a certain \textit{shape} with slots for \textit{components}. These components are elements of the type constructor's type arguments.

        % extract the axioms from here?
        % Explain how F elements are constructed

    \subsection{BNF-axioms}
      We formalize the \ac{BNF}-axioms in \autoref{fig:bnf_axioms} where we use the notation $\overline{f} = f_1 \dots f_l$ for the arguments of the mapper and the relator
      \begin{figure}
        \centering
        \begin{align*}
          \textsc{map\_id: }& \textsf{map}_F\; \overline{id}\; x = x\\
          \textsc{map\_comp: }& \textsf{map}_F\; \overline{g}\; (\textsf{map}_F\; \overline{f}\; x) = \textsf{map}_F\; \overline{(g \circ f)}\; x\\
          \textsc{map\_cong: }& (\forall i.\; \forall z \in \textsf{set}_{F,i}\; x.\; f_i\; z = g_i\; z) \Longrightarrow 
            \textsf{map}_F\; \overline{f}\; x = \textsf{map}_F\; \overline{g}\; x\\
          \textsc{set\_map: }& \forall i.\; \textsf{set}_{F,i} (\textsf{map}_F\; \overline{f}\; x) = f_i\; \grave{\phantom{\_}}\; \textsf{set}_{F,i}\; x\\
          \textsc{bd: }& \textsf{infinite}\; \textsf{bd}_F \land 
            \textsf{regular}\; \textsf{bd}_F \land 
            \textsf{cardinal\_order}\; \textsf{bd}_F\\
          \textsc{set\_bd: }& \forall i.\; | \textsf{set}_{F,i}\; x | <_o \textsf{bd}_F\\
          \textsc{rel\_compp: }& \textsf{rel}_F\; \overline{R}\; \bullet\; \textsf{rel}_F\; \overline{Q}\; = 
            \textsf{rel}_F\; \overline{(R\; \bullet\; Q)}\\
          \textsc{in\_rel: }& \textsf{rel}_F\; \overline{R}\; x\; y =\\
            & \exists z.\; (\forall i.\; \textsf{set}_{F,i}\; z \subseteq \{(a, b).\; R_i\; a\; b \}) \land 
              \textsf{map}_F\; \overline{fst}\; z = x \land \textsf{map}_F\; \overline{snd}\; z = y
        \end{align*}
        \newline
        \footnotesize
        where $\grave{\phantom{\_}}$ is the image function on sets, $\bullet$ is the composition of relations and $<_o$ is the less than relation on cardinals
        \caption{The \ac{BNF} axioms}
        \label{fig:bnf_axioms}
      \end{figure}
      % Explain the other axioms
      % rel_compp has another property

      Additionally to the axioms we already motivated in \autoref{subsec:bnf_constants} (\textsc{map\_id} and \textsc{map\_comp} for the functoriality of $F$, \textsc{set\_map} to ensure that the setters are natural transformations and the boundedness of the setters \textsc{set\_bd}), we have four additional ones.

      One of those is the the congruency \textsc{map\_cong} of the map function. It states that if two (lists of) functions $\overline{f}$ and $\overline{g}$ are equal when applied to the corresponding sets of all components of an $F$ (obtained through the setters), then mapping these two lists of functions over the $F$ each produces the same result. When this propety holds, we can be sure, that the mapper only depends on how the functions $\overline{f}$ behave on the components of the $F$ element.

      The axiom \textsc{bd} just ensures that the bound $\textsf{bd}_F$ is a suitable cardinal, i.e., a regular and infinite one.

      % rel_compp

      Lastly, weak pullback preservation \textsc{in\_rel} is the most abstract and complex axiom. The idea is that two elements $x$ and $y$ of the type $'a\; F$ are related through a relation $R$ iff there exists a $z$ that acts as a "zipped" version of $x$ and $y$. The components of this $z$ are $R_i$-related pairs of the components of $x$ and $y$, where the first position in the pair corresponds to $x$ and the second one to $y$.

    \subsection{Witnesses}
      
    \subsection{BNF examples}
      Further examples of \acp{BNF} are is the product type \type{($'a$, $'b$) prod}, a binary type constructor with infix notation \type{$'a\; \times\; 'b$}, and the type of finite sets \type{$'a$ fset}. The latter is interesting for the reason that it is a subtype of the set type, which is not a \ac{BNF}. By enforcing finiteness for the elements of the type it is possible to give a bound for the set function, fulfilling the \textsc{set\_bd} axiom, which is not possible for the unrestricted set type. Since unboundedness is the only reason that the set type is not a \ac{BNF}, \type{$'a$ fset} can be shown to be a \ac{BNF}.
      
      To show, how \acp{BNF} can be combined to create new ones, we consider the type constructor \type{($'a$, $'b$) plist} = \type{($'a\; \times\; 'b)$ list}. We define for it a map function ($\textsf{map}_\textsf{plist}$) and two set functions ($\textsf{set1}_\textsf{plist}$ and $\textsf{set2}_\textsf{plist}$) as well as a relator $\textsf{rel}_\textsf{plist}\; R\; S$. The exact definitions are given as such:
      \begin{align*}
        \textsf{map}_\textsf{plist}\; f\; g\; &= \textsf{map}_\textsf{list}\; (\textsf{map}_\textsf{prod}\; f\; g)\\
        \textsf{set1}_\textsf{plist}\; xs &= \textsf{set}_\textsf{list}\; (\textsf{map}_\textsf{list}\; fst\; xs)\\
        \textsf{set2}_\textsf{plist}\; xs &= \textsf{set}_\textsf{list}\; (\textsf{map}_\textsf{list}\; snd\; xs)\\
        \textsf{rel}_\textsf{plist}\; R\; S &= \textsf{rel}_\textsf{list} (\textsf{rel}_\textsf{prod}\; R\; S)
      \end{align*}
      \noindent where we use the standard map, set and relator functions of the list and product type.

      To show that \type{($'a$, $'b$) plist} is a \ac{BNF}, we have to prove the \ac{BNF}-axioms for it. Besides the definitions above, a bound $\textsf{bd}_\textsf{plist}$ is needed. We chose $natLeq$. 
      
      % TODO: EXPLAIN bd and natLeq

  \section{Subtype}
    We can carve out a subtype from a type constructor using the \textbf{typedef} command. 
    % The idea was to have this here to show that there exist BNFs that have a dead variable, that are not dead in an MRBNF (but bound). Maybe this idea has to go to the 3 chapter 

  \section{Map-Restricted Bounded Natural Functors (MRBNFs)}
    \acp{MRBNF} are a generalization of \acp{BNF}. Restricting the map function of a functor to \textit{small-support} functions or \textit{small-support bijections} for certain type variables allows us to reason about type constructors in terms of \ac{BNF} properties, even in cases where this would not be possible otherwise. We call type variables that that are restricted to small-support functions \textit{free} variables or \textit{frees} and those restricted to small-support bijections \textit{bound} variables or \textit{bounds}. This allows us to define \acp{MRBNF} with four types of variables (lives, frees, bounds and deads) as opposed to \acp{BNF} which only distinguish between lives and deads. 
    
    Consequently, for type constructors with variables that are considered dead in \ac{BNF} terms, we can declare some of them as free or bound variables, depending on the type. Consider for example the type of distinct lists \type{$'a$ dlist}, a subtype of \type{$'a$ list} that describes only lists containing pairwise distinct $'a$ elements. The issue with this type is that the standard map function on lists cannot guarantee that the resulting list is still distinct, i.e., that it is still part of the type. Thus in \ac{BNF} terms the type variable of \type{$'a$ dlist} is dead. However, by restricting the mapper to only use bijections, the distinctness of the resulting list can be ensured. Thus, it can be shown that \type{$'a$ dlist} is a \ac{MRBNF} with $'a$ as a bound variable.


    \acp{MRBNF} can be used in a \textbf{binder\_datatype} command to produce a datatype with bindings. 
    % binder_datatype command
    
    
  \begin{itemize}
    \item cite \cite{blanchette2019bindings}
  \end{itemize}

