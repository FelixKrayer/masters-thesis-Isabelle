% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Linearizing MRBNFs}
\label{chapter:methodology}

\section{Linearization of MRBNFs (In theory)}
  In this section we define the linearization of a \ac{MRBNF} on a subset of it's \textit{live} variables. The result of the linearization is a new \ac{MRBNF} with the same variable types (\textit{live}, \textit{dead}, \textit{bound}, \textit{free}), except for the linearized variables that change their type from \textit{live} to \textit{bound}. This means that the map function is now restricted to only allow bijective and small-support functions on these variables. Apart from this change, it is ensured that the \ac{MRBNF} is \textit{non-repetitive} with respect to the linearized variables. We give a definition non-repetitiveness in the following \autoref{subsec:nonrep}. Intuitively it means that the atoms of that type cannot occur multiple times in an element of the type.

  \subsection{Non-repetitiveness}
  \label{subsec:nonrep}
    At the core of linearization lies the notion of \textit{non-repetitiveness}. An element $x$ of a type is considered to be non-repetitive with respect to a type variable $\alpha$ if it does not contain repeating $\alpha$-atoms. For example, a \textsf{$\alpha$ list} is non-repetitive, if all of its $\alpha$-elements it contains are pairwise distinct. 
    To define non-repetitiveness for an arbitrary \ac{MRBNF}, we have to express this property in terms of its map, set and relator functions. Considering \textsf{$\alpha$ list}s again, we can show a list $xs$ to be distinct, iff for each other list $ys$ of the same length, we can find a function $f$ such that $ys = \textsf{map}_\textsf{list}\; f\; xs$. If $xs$ were not distinct, there must exist two indices with the same $\alpha$ element in $xs$. Furthermore, there exists a $ys$ that has different elements at these two indices and thus a function mapping $xs$ to $ys$ cannnot exist, since it would have to map two same elements in $xs$ to two differing ones in $ys$. 

    Recalling our model of \ac{BNF}s as containers that have elements of live variables' types in certain positions, we can generalize the notion of lists having the same length to two elements of a type being of equal or equivalent shape. We can express this through the relator by using the $top$ relation that relates everything with each other as the argument. Thus, we give the defninition of equivalent shape and non-repetitiveness for list:
    \begin{align}
      \textsf{eq\_shape}_\textsf{list}\; x\; y &= \textsf{rel}_\textsf{list}\; top\; x\; y\\
      \textsf{nonrep}_\textsf{list}\; x &= \forall y.\; \textsf{\textsf{eq\_shape}}_\textsf{list}\; x\; y \longrightarrow (\exists f.\; y = \textsf{map}_\textsf{list}\; f\; x)
    \end{align}
    
    More interesting is the case of \textsf{($\alpha$, $\beta$) alist} which we only want to be non-repetitive on $\alpha$. For our purpose of defining non-repetitiveness on a subset of the live variables, we fix the other live variables to be equal when defining equivalent shape. 

    Based on this, $x$ is a non-repetitive element, if for all other elements $y$ with equal shape, a function exists through which $x$ can be mapped to $y$. In our example of \textsf{list}, this holds for all lists with distinct elements (given a second list, one can easily define a function mapping the distinct elements of $x$ to that list). It does not hold for lists with repeating elements, because no $f$ exists that could map two equal elements at different positions in this list to distinct elements in an arbitrary second list.

    For \acp{MRBNF} with more than one live variable, we can give a definitions of \textit{non-repetitiveness} and having \textit{equal shape} on a subset of the live variables. In that case, we consider $x$ and $y$ of type $(\alpha, \beta)\; G$ to have equal shape with respect to $\alpha$, iff they are \textit{equal} in their $\beta$ atoms and are related with \textit{top} in $\alpha$ as before. Consequently for the map in the \textsf{nonrep} definition, the \textit{id} function is applied to the $\beta$ atoms, since they are already required to be equal. 
    \begin{align}
      \textsf{eq\_shape}_G^1\; x\; y &= \textsf{rel}_G\; top\; (=)\; x\; y\\
      \textsf{nonrep}_G^1\; x &= \forall y.\; \textsf{eq\_shape}_G^1\; x\; y \Longrightarrow (\exists f.\; y = \textsf{map}_G\; f\; id\; x)
    \end{align}
    
    % TODO: Explain how it is for the linearization of multiple lives?
    
  \subsection{Conditions for linearization}
  \label{subsec:conditions}
    A \acp{MRBNF} has to fulfill two properties to be linearized. First, to ensure that the resulting type constructor is non-empty, it is required, that there exists a non-repetitive element (with respect to the linearized variables): $\exists x.\; \textsf{nonrep}\; x$

    Furthermore, even though \acp{MRBNF} are already required to preserve weak pullbacks as defined in \autoref{eq:WP}, for the linearization it is required that they preserve \textit{all} pullbacks. Formalized this means that the existance of $z$ in the equation has to be fulfilled uniquely, i.e., for each $R$-related $x$ and $y$ there existes \textit{exactly one} $z$ fulfilling the property in \autoref{eq:WP}. For example the strong pullback preservation is fulfilled by the \textsf{$\alpha$ list} and \textsf{$\alpha$ $\beta$ prod} functors but not by \textsf{$\alpha$ fset}, the type constructor for finite sets of $\alpha$s. 

    We note here that the requirement of strong pullback preservation can be omitted, when the \ac{MRBNF} is linearized on all its live variables, i.e., when the linearized \ac{MRBNF} has no live variables. This is because in this case the \textit{relation exchange} lemma explained in Subsection~\ref{par:rel_exchange} becomes trivial. In all other cases, that lemma is the sole reason, strong pullback preservation is required.

  \subsection{Intermediate lemmas}
    We want to prove the \ac{MRBNF} axioms for the linearized \ac{MRBNF}. For this we utilize some intermediate lemmas which we present in this section.
    
    \paragraph{F strong}
      From the pullback preservation with uniqueness we can prove the following lemma. In fact this notion of strongness is equivalent to pullback preservation: 
      \begin{equation*}
        [\![\textsf{rel}_F\; R\; x\; y;\; \textsf{rel}_F\; Q\; x\; y]\!] \Longrightarrow \textsf{rel}_F\; (inf\; R\; Q)\; x\; y
      \end{equation*} 
      where the infimum $inf$ of two relations $R$ and $Q$ relates exactly those elements that are related by both $R$ and $Q$.

    \paragraph{Relation exchange}
    \label{par:rel_exchange}
      The \textit{exchange of relations} is a consequence of the previous property, \textit{F strong}: If two elements $x$ and $y$ are related through the relator with two different lists $\overline{R} = R_1 \dots R_n$ and $\overline{Q} = Q_1 \dots Q_n$ of atom-level relations, then $x$ and $y$ are also related with any index-wise combination of $\overline{R}$ or $\overline{Q}$. For each index $1 \leq i \leq n$ either the relation $R_i$ or $Q_i$ is selected. 
      
      For our purpose of linearization, we are specifically interested in the case, where for all live variables that we linearize on the relation from $\overline{R}$ is chosen and for all others the $Q$ relation. As an example, this results in the following lemma for $(\alpha, \beta)\; G$ from \autoref{subsec:nonrep}:
      \begin{equation*}
        [\![\textsf{rel}_G\; R_1\; R_2\; x\; y;\; \textsf{rel}_G\; Q_1\; Q_2\; x\; y]\!] \Longrightarrow \textsf{rel}_G\; R_1\; Q_2\; x\; y
      \end{equation*} 
      In the specific case, that the \ac{MRBNF} is linearized on \textit{all} of it's live variables, the goal of the lemma is equal to it's first assumption. Thus, the lemma becomes trivial since exactly the list of relations $\overline{R}$ is chosen.

      As a consequence of this, the previous lemma \textit{F strong} is not needed to prove this lemma. Furthermore, this lemma is the sole reason why \textit{F strong} and strong pullback preservation are needed for the linearization. Thus the requirement of pullback preservation can be lifted, in the case that the linearization is applied to all live variables at the same time.

    \paragraph{map peresrving non-repetitiveness}
      \begin{equation*}
        [\![\textsf{nonrep}_G^1\; x;\; \textsf{bijective} f]\!] \Longrightarrow \textsf{nonrep}_G^1\; (\textsf{map}_G\; f\; g\; x)
      \end{equation*} 
      
  \subsection{Proving the MRBNF axioms}

  \subsection{Non-emptines Witnesses}
  \label{subsec:wits}

  \section{Linearization of MRBNFs (In Isabelle)}
    We implement a command that allows the user to linearize an existing \ac{MRBNF} or \ac{BNF} on one or multiple of it's live variables. The syntax of the command is given in the following:

    \input{figures/linearize_rail.tex}

    With this command, we can linearize our example by writing the following line in Isabelle:
    \begin{equation*}
      \textbf{linearize\_mrbnf}\; (\text{keys:}\; 'k :: \text{var},\; \text{vals:}\; 'v)\; \text{alist} = ('k :: \text{var}\; \times\; 'v)\; \text{list}\; \textbf{on}\; 'a
    \end{equation*}
    Since for $('k\; \times\; 'v)\; \text{list}$ both type variables are live and we only linearize on $'k$, it is necessary to prove strong pullback preservation for this \ac{MRBNF}. 

    After the user has written the command, the conditions for linearization we presented in~\autoref{subsec:conditions} have to be proven, i.e., non-emptines of the linear type and strong pullback preservation. 
    
    These conditions are given dynamically to the user. For example, strong pullback preservation only has to be shown, when the resulting \ac{MRBNF} has live variables remaining. Furthermore, the non-emptines of the non-repetitive type is easily proven when the user specified a non-emptines witness, or a preservable witness of the original type exists. Thus, the user is not asked to show the existance of a non-repetitive element in these cases.

    
    

    
    % TODO: Implementation in Isabelle (theorem names, definitions)
    % resulting MRBNF is also "strong" (preserves all pullbacks)

  